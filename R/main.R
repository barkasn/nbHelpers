#' @author Nikolas Barkas
#' @importFrom utils read.table
#' @importFrom Matrix readMM
NULL

#' @title Find minimum string distance strings in a vector
#' @description Find the minimum string distance between strings in a vector,
#' this is useful for things like finding the number of allowable barcode
#' mismatches
#' @importFrom stringdist stringdistmatrix
#' @export minStringDistance
minStringDistance <- function(strings) {
  ds <- stringdist::stringdistmatrix(strings,strings);
  min(ds[upper.tri(ds)])
}

#' @title  Read 10x matrix
#' @description This function reads a matrix generated by the 10x processing pipeline
#' from the specified directory and returns it. It aborts if one of the required
#' files in the specified directory do not exist.
#'
#' @param path location of 10x output
#'
#' @return read matrix
#'
#' @export read10xMatrix
read10xMatrix <- function(path) {
  require(Matrix)

  matrixFile <- paste(path, 'matrix.mtx', sep='/');
  genesFile <- paste(path, 'genes.tsv', sep='/');
  barcodesFile <- paste(path, 'barcodes.tsv', sep='/');

  if (!file.exists(matrixFile)) { stop('Matrix file does not exist');  }
  if (!file.exists(genesFile)) { stop('Genes file does not exist'); }
  if (!file.exists(barcodesFile)) { stop('Barcodes file does not exist'); }

  x <- as(Matrix::readMM(matrixFile), 'dgCMatrix')

  genes <- read.table(genesFile)
  rownames(x) <- genes[,2];

  barcodes <- read.table(barcodesFile);
  colnames(x) <- barcodes[,1]
  invisible(x);
}

#' @title get NW, NE, SW and SE corners of a dataframe or matrix
#' @description return a new dataframe or matrix with the elements at the
#' four corners of the one provided
#'
#' @param vals the dataframe or matrix of interest
#' @param n how many rows/cols to return from each end
#'
#' @return the new matrix
#'
#' @export tableCorners
tableCorners <- function(vals, n = 4) {
  d <- dim(vals)
  rows <- c(1:n,(d[1]-n):(d[1]))
  cols <- c(1:n,(d[2]-n):(d[2]))
  vals[rows, cols]
}


#' @title save a R session image fast
#' @description saves an R image of the current session much faster and with
#' better compression that the built-in save.image function. Requires system lbzip2
#' utility
#' @param filename the file to save the image to
#' @param tmpfile optional temporary file name, using a ramdisk location will further accelerate saving
#' @param verbose logical verbosity level
#' @export save.image.fast
save.image.fast <- function(filename,tmpfile = NULL, verbose = FALSE) {
  if (is.null(filename)) {
    stop("filename argument is required");
  }
  if (is.null(tmpfile)) {
    tmpfile <- tempfile();
  }

  if (verbose) { cat('Saving to temp file ', tmpfile,'\n') }
  save.image(tmpfile, compress = FALSE);

  cmd <- paste0('lbzip2 -c ', tmpfile, ' > ', filename)

  if (verbose) { cat('Compressing...\n') };
  system(cmd);

  if (verbose) { cat('Deleting temporary file...') }
  unlink(tmpfile)
}

#' Loads an image generated with save.image.fast()
#' @description loads an image generated with the save.image.fast function. This function
#' requires that the system has the lbunzip2 command installed
#' @param tmpfile temporary file to use, use of ramdisk file will accelerate loading
#' @param verbose logical verbosity level
#' @param envir enviroment in which to load the data, by default the calling environment
#' @export load.image.fast
load.image.fast <- function(filename, tmpfile = NULL, verbose=F, envir = parent.frame()) {
  if (is.null(filename)) {
    stop('filename argument is required');
  }
  if (is.null(tmpfile)) {
    tmpfile <- tempfile();
  }

  if (verbose) { cat('Decompressing into temporary file ', tmpfile, '...\n') }
  cmd <- paste0('lbunzip2 -c ', filename, ' > ', tmpfile);
  system(cmd);

  if  (verbose) { cat('Loading...\n') }
  load(tmpfile, envir = envir);

  if (verbose) { cat('Deleting temporary file...\n') }
  unlink(tmpfile);
}

#' Generates a new vector from two vectors by combining them according to a third
#' @description generates a vector from two vectors depending of the logical value of
#' a third vector
#' @param logical vector to use to combine the vTrue and vFalse vectors
#' @param vTrue values to return if the logical is true
#' @param vFalse values to return if the logical is false
#' @return a new vector with some values from vTrue and some for vFalse
#' @export mixVectorsOnLogical
mixVectorsOnLogical <- function(logical,vTrue,vFalse) {
  mapply(function(v, vt, vf) {ifelse(v, vt, vf)}, logical, vTrue, vFalse);
}
